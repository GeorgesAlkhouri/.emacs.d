;-*- eval: (load-file "./init-dev.el");   -*-
#+title: My Emacs Configuration
#+property: header-args :mkdirp yes :tangle yes :tangle-mode (identity #o444) :results silent :noweb yes
#+startup: indent

Idea and basics from https://github.com/progfolio/.emacs.d

* An Explanation
This is a literate configuration for =Emacs=.
Tangling this file creates two Elisp files, =~/.emacs.d/init.el= and =~/.emacs.d/early-init.el=.

** Todos
- add restart lsp workspace key-binding
- add auto venv switch
- add better parentheses 
- add all the icons
- env variable (DONE when started from shell)
- format org file
- add emacs application framework
- quick access for windows by numbers
  
* Requirements
Dependencies you need to fully run all configured features:
- ag
- vterm requirements
- pyright, black, flake8, pylint, isort, mypy

* Tangle
 
Start with =make tangle= to create the init.el and early-init.el from this org file.

* Bootstrapping
** early-init
:PROPERTIES:
:header-args: :tangle-mode (identity #o444) :results silent :tangle ~/.emacs.d/early-init.el
:END:
Emacs 27.0 introduced an early-init file. It allows customization before package and UI initialization.
#+begin_src emacs-lisp
;;; early-init.el --- Emacs pre package.el & GUI configuration -*- lexical-binding: t; -*-
;;; Code:
#+end_src

We want the latest version of Org mode.

Removing the Emacs bundled version from the load-path *should* prevent loading mixed Org versions.
e.g. After updating Org mode.
#+begin_src emacs-lisp
(when-let (orglib (locate-library "org" nil load-path))
  (setq-default load-path (delete (substring (file-name-directory orglib) 0 -1)
                                  load-path)))
#+end_src

Save some time at startup.
#+begin_src emacs-lisp
(setq package-enable-at-startup nil)
#+end_src

*** Debugging

Silence native compilation compiler warnings for as they can be pretty disruptive.
#+begin_src emacs-lisp :tangle yes
(setq native-comp-async-report-warnings-errors nil)
#+end_src

Running this form will launch the debugger after loading a package.
This is useful for finding out when a dependency is requiring a package (perhaps earlier than you want).
Use by tangling this block and launching Emacs with =emacs --debug-init=.
#+begin_src emacs-lisp :var file="" :results silent :tangle no
(unless (string-empty-p file)
  (eval-after-load file
    '(debug)))
#+end_src

Similarly, this variable will hit the debugger when a message matches its regexp.
#+begin_src emacs-lisp :tangle no
(setq debug-on-message "")
#+end_src

Adding a variable watcher can be a useful way to track down initialization and mutation of a variable.
#+begin_src emacs-lisp :tangle no
(add-variable-watcher 'org-capture-after-finalize-hook
                      (lambda (symbol newval operation where)
                        (debug)
                        (message "%s set to %s" symbol newval)))
#+end_src

*** initial-major-mode
Prevent the \*scratch* buffer from loading a mode.
#+begin_src emacs-lisp :tangle no
(setq initial-major-mode 'fundamental-mode)
#+end_src

*** file-name-handler-alist
Skipping a bunch of regular expression searching in the =file-name-handler-alist= should improve start time.
#+begin_src emacs-lisp
(defvar default-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
#+end_src

*** gc-cons threshold
Emacs collects garbage every 800KB.
This is overly aggressive on a modern machine during our init.
Temporarily turning it off should decrease startup times.
Resetting it afterward will ensure that normal operations don't suffer from a large GC period.

I'm still not sure on the optimal gc-cons-threshold value. The following is a
table of values from popular Emacs configurations.

| Distribution | gc-cons-threshold |
|--------------+-------------------|
| Default      |            800000 |
| Doom         |          16777216 |
| Spacemacs    |         100000000 |

#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum)

(defun +gc-after-focus-change ()
  "Run GC when frame loses focus."
  (run-with-idle-timer
   5 nil
   (lambda () (unless (frame-focus-state) (garbage-collect)))))
#+end_src

#+begin_src emacs-lisp
(defun +reset-init-values ()
  (run-with-idle-timer
   5 nil
   (lambda ()
     (setq file-name-handler-alist default-file-name-handler-alist
           gc-cons-threshold 100000000)
     (message "gc-cons-threshold & file-name-handler-alist restored")
     (when (boundp 'after-focus-change-function)
       (add-function :after after-focus-change-function #'+gc-after-focus-change)))))

(add-hook 'emacs-startup-hook '+reset-init-values)
#+end_src

*** read process output max value
Enlargen the maximum number of bytes to read from subprocess in a single chunk.
Good for speeding up language servers.

#+begin_src emacs-lisp
  (setq read-process-output-max (* 1024 1024)) ;; 1mb
#+end_src

*** UI
Turning off these visual elements before UI initialization should speed up init.
#+begin_src emacs-lisp
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)
#+end_src

Implicitly resizing the Emacs frame adds to init time.
Fonts larger than the system default can cause frame resizing, which adds to startup time.
#+begin_src emacs-lisp
(setq frame-inhibit-implied-resize t)
#+end_src

Set default and backup fonts
#+begin_src emacs-lisp
(push '(font . "Source Code Pro") default-frame-alist)
(set-face-font 'default "Source Code Pro")
(set-face-font 'variable-pitch "DejaVu Sans")
(copy-face 'default 'fixed-pitch)
#+end_src
Ignore X resources.
#+begin_src emacs-lisp
(advice-add #'x-apply-session-resources :override #'ignore)
#+end_src


Taken from:

[[https://github.com/vsemyonoff/emacsrc/blob/14649a5bafea99cc7e13e7d048e9d15aed7926ce/early-init.el]]

This helps with a bug I was hitting when using =desktop-save-mode='s =desktop-read=.
#+begin_src emacs-lisp
(setq desktop-restore-forces-onscreen nil)
#+end_src

*** provide early-init
#+begin_src emacs-lisp
(provide 'early-init)
;;; early-init.el ends here
#+end_src

** lexical binding
The following line turns on lexical binding for performance reasons.
#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
#+end_src

** Straight package manager
#+begin_quote
straight.el: next-generation, purely functional package manager for the Emacs hacker.

https://github.com/raxod502/straight.el
#+end_quote
Straight installs packages directly from there git repository.

Bootstrap straight
Caveat:

#+begin_quote
Sometimes, in a corporate environment, url-retrieve-synchronously may not work and straight.el
will be unable to download the installation script mentioned in the bootstrap snippet.
In this case, you may simply clone this repository into ~/.emacs.d/straight/repos/straight.el and
check out your desired revision/branch.
#+end_quote

#+begin_src emacs-lisp
(setq straight-repository-branch "develop")
(setq straight-check-for-modifications '(check-on-save))
(setq straight-use-package-by-default t)
(setq straight-vc-git-default-protocol 'https)
(setq straight-vc-git-force-protocol nil)
(defvar bootstrap-version)
;;(setq straight-host-usernames '((github . "progfolio")
;;                                (gitlab . "iarchivedmywholelife")))
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

*** Install org-contrib
Installing it this early *should* prevent mixed Org installations.
#+begin_src emacs-lisp
(straight-use-package 'org-contrib)
#+end_src

** profiling
This function displays how long Emacs took to start.
It's a rough way of knowing when/if I need to optimize my init file.
#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs loaded in %s with %d garbage collecitons."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+end_src
** packaging
*** use-package
#+begin_src emacs-lisp
(straight-use-package 'use-package)
(eval-when-compile
  (require 'use-package))
#+end_src

#+begin_src emacs-lisp
(setq init-file-debug nil)
(if init-file-debug
    (setq use-package-verbose t
          use-package-expand-minimally nil
          use-package-compute-statistics t
          debug-on-error t)
  (setq use-package-verbose nil
        use-package-expand-minimally t))
#+end_src

** after start up
After start up do some UI changes.
#+begin_src emacs-lisp
  (defun after-startup ()
    (set-face-attribute 'default nil :height 140)
    (toggle-frame-maximized)
  )
  
  (add-hook 'after-init-hook #'after-startup)
  
#+end_src
* Packages
** evil
#+begin_quote
Evil is an extensible vi layer for Emacs. It emulates the main features of Vim, and provides facilities for writing custom extensions.
[...] evil-collection assumes evil-want-keybinding is set to nil and evil-want-integration is set to t before loading evil and evil-collection.
https://github.com/emacs-evil/evil
#+end_quote
#+begin_src emacs-lisp
  (use-package evil
    :demand t
    :init
    (setq evil-want-integration t)
    (setq evil-undo-system 'undo-redo)
    (setq evil-want-keybinding nil)
    :hook (after-init . evil-mode))
#+end_src

*** evil-collection
#+begin_quote
This is a collection of Evil bindings for the parts of Emacs that Evil does not cover properly by default.

https://github.com/emacs-evil/evil-collection
#+end_quote
#+begin_src emacs-lisp
   (use-package evil-collection
     :after (evil)
     :config
  ;;Whether to setup Evil bindings in the minibuffer.
  (setq evil-collection-setup-minibuffer t)
  (evil-collection-init)
   )
#+end_src

** general (key-bindings)
#+begin_quote
general.el provides a more convenient method for binding keys in emacs (for both evil and non-evil users).

https://github.com/noctuid/general.el#about
#+end_quote

Load general before the remaining packages so they can make use of the ~:general~ keyword in their declarations.

#+begin_src emacs-lisp
  (use-package general
    :config (add-to-list 'general-non-normal-states 'visual)
    :demand t)
#+end_src

*** config key-bindings

#+begin_src emacs-lisp
  ;; We define a global-leader definer to access major-mode specific bindings
    (general-create-definer global-leader :states '(normal visual) :prefix "SPC m"
      "" '( :ignore t
                  :which-key
                  (lambda (arg)
                  (cons (cadr (split-string (car arg) " "))
              (replace-regexp-in-string "-mode$" "" (symbol-name major-mode))))))
 ;; Also define a global menu definer  
    (general-create-definer global-menu :states '(normal visual) :prefix "SPC" )
     (global-menu "!" 'shell-command
      ":"   'eval-expression
      "TAB" '((lambda () (interactive) (switch-to-buffer nil))
          :which-key "other-buffer")
     )
#+end_src

**** applications
#+begin_src emacs-lisp
(general-create-definer global-menu-applications :keymaps 'override :states '(normal visual) :prefix "SPC a" "" '(:ignore t :which-key "applications"))
#+end_src

**** search
#+begin_src emacs-lisp
(general-create-definer global-menu-search :keymaps 'override :states '(normal visual) :prefix "SPC s" "" '(:ignore t :which-key "search"))
#+end_src

**** spelling
#+begin_src emacs-lisp
(general-create-definer global-menu-spelling :keymaps 'override :states '(normal visual) :prefix "SPC S" "" '(:ignore t :which-key "spelling"))
#+end_src

**** buffer
#+begin_src emacs-lisp
    (general-create-definer global-menu-buffer :states '(normal visual) :prefix "SPC b" "" '(:ignore t :which-key "buffer"))
    (global-menu-buffer
         "d"  'kill-current-buffer
         "o" '((lambda () (interactive) (switch-to-buffer nil))
               :which-key "other-buffer")
         "r"  'rename-buffer
         "R"  'revert-buffer
         "M" '((lambda () (interactive) (switch-to-buffer "*Messages*"))
               :which-key "messages-buffer")
         "s" '((lambda () (interactive) (switch-to-buffer "*scratch*"))
               :which-key "scratch-buffer")
  )
#+end_src

**** jumping/ joining / spliting
#+begin_src emacs-lisp
  (general-create-definer global-menu-jump :states '(normal visual) :prefix "SPC j" "" '(:ignore t :which-key "jump"))
#+end_src

**** files
#+begin_src emacs-lisp
    (general-create-definer global-menu-file :states '(normal visual) :prefix "SPC f" "" '(:ignore t :which-key "file"))
#+end_src

**** env
Menus for everything releated to Emacs environmental files, settings, etc. 
#+begin_src emacs-lisp
  (general-create-definer global-menu-env :states '(normal visual) :prefix "SPC e" "" '(:ignore t :which-key "env"))
  (global-menu-env 
     "d" '((lambda () (interactive) (find-file (expand-file-name "init.org" user-emacs-directory))) :which-key "init.org config")
     "f" '(straight-freeze-versions :which-key "freeze packages")
  )
#+end_src

**** git
#+begin_src emacs-lisp
  (general-create-definer global-menu-vc :states '(normal visual) :prefix "SPC g" "" '(:ignore t :which-key "git"))
#+end_src

**** windows
#+begin_src emacs-lisp
  (general-create-definer global-menu-window :states '(normal visual) :prefix "SPC w" "" '(:ignore t :which-key "window"))
  (global-menu-window
  
          "?" 'split-window-vertically
          "=" 'balance-windows-area
          "/" 'split-window-horizontally
          "O" 'delete-other-windows
          "X" '((lambda () (interactive) (call-interactively #'other-window) (kill-buffer-and-window))
                :which-key "kill-other-buffer-and-window")
          "H" 'evil-window-move-far-left
          "J" 'evil-window-move-very-bottom
          "K" 'evil-window-move-very-top
          "L" 'evil-window-move-far-right
          "d" 'delete-window
          "h" 'windmove-left
          "j" 'windmove-down
          "k" 'windmove-up
          "l" 'windmove-right
          "o" 'other-window
          "t" '((lambda () (interactive)
                  "toggle window dedication"
                  (set-window-dedicated-p (selected-window) (not (window-dedicated-p))))
                :which-key "toggle window dedication")
          "x" 'kill-buffer-and-window
   )  
#+end_src

**** projects
#+begin_src emacs-lisp
 (general-create-definer global-menu-project :states '(normal visual) :prefix "SPC p" "" '(:ignore t :which-key "project"))
#+end_src
 
** which-key
#+begin_quote
which-key is a minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup.

https://github.com/justbur/emacs-which-key
#+end_quote
#+begin_src emacs-lisp
  (use-package which-key
    :demand t
    :config
    (which-key-mode)
    :custom
    (which-key-side-window-location 'bottom)
    (which-key-sort-order 'which-key-key-order-alpha)
    (which-key-side-window-max-width 0.33)
    (which-key-idle-delay 0.05)
    :diminish )
#+end_src

** magit
#+begin_quote
Magit is an interface to the version control system Git, implemented as an Emacs package.

https://magit.vc/
#+end_quote
#+begin_src emacs-lisp
      (use-package magit
        :defer t
        :after (general)
        :general
        (global-menu-vc
      "b"  'magit-blame
        "i"  'magit-init
         "s"  'magit-status
         )
        :config
        (transient-bind-q-to-quit))
#+end_src

** company
#+begin_quote
Company is a text completion framework for Emacs.
The name stands for "complete anything".
It uses pluggable back-ends and front-ends to retrieve and display completion candidates.

http://company-mode.github.io/
#+end_quote
#+begin_src emacs-lisp :lexical t
        (use-package company
          :defer 5
        :diminish
        :commands (company-mode global-company-mode)
        :custom
    (company-idle-delay 0.01)
      (company-minimum-prefix-length 2)
  :general
  (general-def company-active-map "C-k"    'company-select-previous)
  (general-def company-active-map "C-j"    'company-select-next)
  (general-def company-active-map "<tab>"    'company-complete-common-or-cycle)
  (general-def company-active-map "S-<tab>"    'company-select-previous)
  :config
  (global-company-mode)
  )
#+end_src

** helm
#+begin_quote
Helm is an Emacs framework for incremental completions and narrowing selections.

https://github.com/emacs-helm/helm
#+end_quote
#+begin_src emacs-lisp
    (use-package helm
    :init (require 'helm-config)
    :diminish
    :defer 1
    :config
    (helm-mode)
    :general
    (general-def helm-map "<tab>" 'helm-execute-persistent-action)
    (general-def helm-map "TAB" 'helm-execute-persistent-action)
    (general-def helm-map "C-a" 'helm-select-action)
    (general-def helm-map "C-h" 'helm-find-files-up-one-level)
    (general-def helm-map "C-j" 'helm-next-line)
    (general-def helm-map "C-k" 'helm-previous-line)
    (global-menu
       "SPC" '(helm-M-x :which-key "M-x")
       "/"   'helm-projectile-ag)
    (global-menu-search
       "s" 'helm-occur)
    (global-menu-file
     "f" 'helm-find-files
     "F" 'helm-find
     "r" 'helm-recentf)
    (global-menu-buffer
       "b" 'helm-mini)
    (global-menu-jump
         "i" 'helm-imenu)
  )
#+end_src

*** helm-ag
#+begin_quote
helm-ag.el provides interfaces of The Silver Searcher with helm.

https://github.com/emacsorphanage/helm-ag
#+end_quote
#+begin_src emacs-lisp :lexical t
(use-package helm-ag
  :commands (helm-ag helm-projectile-ag))
#+end_src

*** helm-projectile
#+begin_src emacs-lisp
  (use-package helm-projectile
    :after (helm)
    :general
    (global-menu-project
       "d" 'helm-projectile-find-dir
       "f" 'helm-projectile-find-file
       "p" 'helm-projectile-switch-project
       "r" 'helm-projectile-recentf)
  )
#+end_src

** projectile
#+begin_quote
Projectile is a project interaction library for Emacs.
Its goal is to provide a nice set of features operating on a project level without introducing external dependencies (when feasible).

https://github.com/bbatsov/projectile
#+end_quote
#+begin_src emacs-lisp
(use-package projectile
  :after (general)
  :general
  (global-menu-project
     "!" 'projectile-run-shell-command-in-root
     "%" 'projectile-replace-regexp
     "D" 'projectile-dired
     "e" 'projectile-edit-dir-locals
     "g" 'projectile-find-tag
     "G" 'projectile-regenerate-tags
     "R" 'projectile-replace
     "v" 'projectile-vc)
  :config
  (projectile-mode))
#+end_src

** vterm
#+begin_quote
Emacs-libvterm (vterm) is fully-fledged terminal emulator inside GNU Emacs based on libvterm, a C library.

https://github.com/akermu/emacs-libvterm
#+end_quote
#+begin_src emacs-lisp
  (use-package vterm
    :straight (:post-build (cl-letf (((symbol-function #'pop-to-buffer)
                                      (lambda (buffer) (with-current-buffer buffer (message (buffer-string))))))
                             (setq vterm-always-compile-module t)
                            (require 'vterm)))
    :commands (vterm vterm-other-window)
    :general
    (global-menu-applications "t" '(:ignore t :which-key "terminal") "tt" 'vterm-other-window
         "t." 'vterm
    )
    :config
    (evil-set-initial-state 'vterm-mode 'emacs))
#+end_src

** diminish
#+begin_quote
This package implements hiding or abbreviation of the mode line displays (lighters) of minor-modes.

https://github.com/emacsmirror/diminish
#+end_quote
#+begin_src emacs-lisp :lexical t
(use-package diminish
  :defer 3)
#+end_src

** expand-region
#+begin_quote
Expand region increases the selected region by semantic units. Just keep pressing the key until it selects what you want.

https://github.com/magnars/expand-region.el

See also
https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#why-do-non-evil-users-get-expand-region-but-not-evil-users
to learn about the VIM way.
#+end_quote
#+begin_src emacs-lisp
     (use-package expand-region
        :commands er/expand-region
        :config
     (setq expand-region-contract-fast-key "V"
               expand-region-reset-fast-key "r")
     :general
     (global-menu
      "v"   'er/expand-region)
     )
    
#+end_src
** Development
Following packages are used majorly for programming
*** evil-nerd-commenter
#+begin_quote
A Nerd Commenter emulation, help you comment code efficiently.

https://github.com/redguardtoo/evil-nerd-commenter
#+end_quote

#+begin_src emacs-lisp
   (use-package evil-nerd-commenter
         :commands evilnc-comment-or-uncomment-lines
        :general
    (global-menu ";" '(evilnc-comment-or-uncomment-lines :which-key "evil-comment"))
    )
#+end_src

*** lsp-mode
#+begin_quote
Client for Language Server Protocol.
lsp-mode aims to provide IDE-like experience by providing optional integration with the most popular Emacs packages like company, flycheck and projectile.
#+end_quote

#+begin_src emacs-lisp
  (use-package lsp-mode
  :hook (lsp-mode . lsp-enable-which-key-integration)
  :commands lsp-deferred
  ;; disable flycheck override with lsp checker in python-mode
  :config (setq lsp-diagnostics-disabled-modes '(python-mode)) 
  :general
  (global-leader :keymaps 'python-mode-map "r" 'lsp-rename
  "g" '(:ignore t :which-key "goto") "gd" 'evil-goto-definition
   ))
  
  (use-package lsp-ui
    :commands lsp-ui-mode)
  (use-package helm-lsp
    :commands helm-lsp-workspace-symbol)
  
#+end_src

*** flycheck
#+begin_quote
Flycheck is a modern on-the-fly syntax checking extension for GNU Emacs, intended as replacement for the older Flymake extension which is part of GNU Emacs.

https://www.flycheck.org/en/latest/
#+end_quote
#+begin_src emacs-lisp
     (use-package flycheck
     :defer t
     :init 
    (add-hook 'python-mode-hook #'(lambda ()
           (flycheck-mode)
           ;; checker setup locally for python-mode
           ;; explicitly set flake8 checker
           ;; implicitly set mypy and pylint in checker chain
           (setq-local flycheck-checker 'python-flake8)))
    :custom (flycheck-emacs-lisp-load-path 'inherit "necessary with straight.el")
  )
#+end_src

*** Python

**** lsp-pyright
#+begin_src emacs-lisp
  (use-package lsp-pyright
  :defer t
  :hook (python-mode . (lambda ()
                          (require 'lsp-pyright)
                          (lsp-deferred))))
#+end_src

**** pyvenv
#+begin_src emacs-lisp
  (use-package pyvenv
  :defer t
  :diminish
  :config
  ;; Show python venv name in modeline
  (setq pyvenv-mode-line-indicator '(pyvenv-virtual-env-name ("[venv:" pyvenv-virtual-env-name "] ")))
  :hook (python-mode . pyvenv-mode)
  )
#+end_src

**** blacken
#+begin_src emacs-lisp
      (use-package blacken :defer t :commands blacken-buffer
        ;; only format buffer when in python-mode
        :init (add-hook 'before-save-hook #'(lambda () (when (derived-mode-p 'python-mode)
           (blacken-buffer)
           )))
      )
#+end_src

**** pytest-el
https://github.com/ionrock/pytest-el

- FIX  Package cl is deprecated
#+begin_src emacs-lisp
  (use-package pytest :defer t
  :commands (pytest-one ptytest-module pytest-all)
  :config (add-to-list 'pytest-project-root-files "setup.cfg")
  :general
   (global-leader :keymaps 'python-mode-map "t" '(:ignore t :which-key "testing")
     "tt" 'pytest-one "ta" 'pytest-all "tb" 'pytest-module
   )
  )
#+end_src

**** py-isort
#+begin_src emacs-lisp
  (use-package py-isort
    :commands py-isort-before-save
    :init
  ;;isort checks if in python-mode
    (add-hook 'before-save-hook 'py-isort-before-save))
#+end_src
** Themes

https://github.com/hlissner/emacs-doom-themes

- TODO Look into defering theme loading (=emacs-startup=) to save some startup time
  
#+begin_src emacs-lisp
      (use-package doom-themes
      :config
      ;; Global settings (defaults)
      (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
            doom-themes-enable-italic t) ; if nil, italics is universally disabled
      (load-theme 'doom-one-light t)
      ;; Enable flashing mode-line on errors
      (doom-themes-visual-bell-config)
      ;; Corrects (and improves) org-mode's native fontification.
      (doom-themes-org-config)
      :general
      (global-menu-env "t" '(:ignore t :which-key "themes")
     "t1" '((lambda () (interactive)
                (load-theme 'doom-one t))
              :which-key "doom-one")
     "t2" '((lambda () (interactive)
                  (load-theme 'doom-one-light t))
                :which-key "doom-one-light")
   )
  )
#+end_src


#+begin_src emacs-lisp
  (use-package doom-modeline
  :defer t
  :hook
  (after-init . doom-modeline-mode))
#+end_src

** Hyda
 Hydra helps to design transient key bindings.

 https://github.com/abo-abo/hydra
 #+begin_src  emacs-lisp
   (use-package hydra
     :defer t
     :config
   (defhydra hydra-text-scale (:timeout 4)
       "scale text"
       ("j" text-scale-increase "in")
       ("k" text-scale-decrease "out")
       ("q" nil "finished" :exit t))
     :general
     (global-menu-env "s" '(hydra-text-scale/body :which-key "scale text")) 
     )
   
 #+end_src
** flyspell
#+begin_quote
Flyspell enables on-the-fly spell checking in Emacs by the means of a minor mode.

http://www-sop.inria.fr/members/Manuel.Serrano/flyspell/flyspell.html
#+end_quote

- FIX ispell starts also in init major mode which is fundamental mode
- TODO add German dict to ispell
- TODO add cycling hydra menu for spell checking

#+begin_src emacs-lisp
   (use-package flyspell
    :defer t
    :hook ((prog-mode . flyspell-prog-mode)
           (text-mode . flyspell-mode))
    :config
    ;; better performance, see https://www.emacswiki.org/emacs/FlySpell#h5o-3
    (setq flyspell-issue-message-flag nil)
  )
#+end_src

** flyspell-correct
#+begin_quote
Correcting misspelled words with flyspell using favourite interface.
Helm in this case.

https://github.com/d12frosted/flyspell-correct
#+end_quote

#+begin_src emacs-lisp
    (use-package flyspell-correct
     :defer t
     :after flyspell
     :general
     (global-menu-spelling "c" '(flyspell-correct-wrapper :which-key "check"))
  )
  
  (use-package flyspell-correct-helm
  :defer t
  :after flyspell-correct)
  
#+end_src

** winner
Winner Mode is a global minor mode that allows you to “undo” and “redo” changes in WindowConfiguration
(Changes in window state).
#+begin_src emacs-lisp
  (use-package winner
  :defer 3
  :general
  (global-menu-window
    "u" 'winner-undo
    "r" 'winner-redo)
  :config (winner-mode))
#+end_src
