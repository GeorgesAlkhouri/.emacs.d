;-*- eval: (load-file "./init-dev.el");   -*-
#+title: My Emacs Configuration
#+property: header-args :mkdirp yes :tangle yes :tangle-mode (identity #o444) :results silent :noweb yes
#+startup: indent

From https://github.com/progfolio/.emacs.d

* TODO
- remove C-k default binding and bind in to helm-prev-line
- add development setup (python, completition)
  - lsp, flycheck, pyright, etc.
- add ispell
- env variable
- better shell integration
* Usage

Start with *make tangle* to create the init.el from this org file.

* An Explanation
This is a literate configuration for =Emacs=.
Tangling this file creates an Elisp file, =~/.emacs.d/lisp/init.el=.
* Bootstrapping
** early-init
:PROPERTIES:
:header-args: :tangle-mode (identity #o444) :results silent :tangle ~/.emacs.d/early-init.el
:END:
Emacs 27.0 introduced an early-init file. It allows customization before package and UI initialization.
#+begin_src emacs-lisp
;;; early-init.el --- Emacs pre package.el & GUI configuration -*- lexical-binding: t; -*-
;;; Code:
#+end_src

We want the latest version of Org mode.
Removing the Emacs bundled version from the load-path *should* prevent loading mixed Org versions.
e.g. After updating Org mode.
#+begin_src emacs-lisp
(when-let (orglib (locate-library "org" nil load-path))
  (setq-default load-path (delete (substring (file-name-directory orglib) 0 -1)
                                  load-path)))
#+end_src

Save some time at startup.
#+begin_src emacs-lisp
(setq package-enable-at-startup nil)
#+end_src

*** Debugging
Running this form will launch the debugger after loading a package.
This is useful for finding out when a dependency is requiring a package (perhaps earlier than you want).
Use by tangling this block and launching Emacs with =emacs --debug-init=.
#+begin_src emacs-lisp :var file="" :results silent :tangle no
(unless (string-empty-p file)
  (eval-after-load file
    '(debug)))
#+end_src

Similarly, this variable will hit the debugger when a message matches its regexp.
#+begin_src emacs-lisp :tangle no
(setq debug-on-message "")
#+end_src

Adding a variable watcher can be a useful way to track down initialization and mutation of a variable.
#+begin_src emacs-lisp :tangle no
(add-variable-watcher 'org-capture-after-finalize-hook
                      (lambda (symbol newval operation where)
                        (debug)
                        (message "%s set to %s" symbol newval)))
#+end_src

*** initial-major-mode
Prevent the \*scratch* buffer from loading a mode.
#+begin_src emacs-lisp :tangle no
(setq initial-major-mode 'fundamental-mode)
#+end_src

*** file-name-handler-alist
Skipping a bunch of regular expression searching in the =file-name-handler-alist= should improve start time.
#+begin_src emacs-lisp
(defvar default-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
#+end_src

*** gc-cons threshold
Emacs collects garbage every 800KB.
This is overly aggressive on a modern machine during our init.
Temporarily turning it off should decrease startup times.
Resetting it afterward will ensure that normal operations don't suffer from a large GC period.

I'm still not sure on the optimal gc-cons-threshold value. The following is a
table of values from popular Emacs configurations.

| Distribution | gc-cons-threshold |
|--------------+-------------------|
| Default      |            800000 |
| Doom         |          16777216 |
| Spacemacs    |         100000000 |

#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum)

(defun +gc-after-focus-change ()
  "Run GC when frame loses focus."
  (run-with-idle-timer
   5 nil
   (lambda () (unless (frame-focus-state) (garbage-collect)))))
#+end_src

#+begin_src emacs-lisp
(defun +reset-init-values ()
  (run-with-idle-timer
   5 nil
   (lambda ()
     (setq file-name-handler-alist default-file-name-handler-alist
           gc-cons-threshold 100000000)
     (message "gc-cons-threshold & file-name-handler-alist restored")
     (when (boundp 'after-focus-change-function)
       (add-function :after after-focus-change-function #'+gc-after-focus-change)))))

(add-hook 'emacs-startup-hook '+reset-init-values)
#+end_src

*** read process output max value
Enlargen the maximum number of bytes to read from subprocess in a single chunk.
Good for speeding up language servers.

#+begin_src emacs-lisp
  (setq read-process-output-max (* 1024 1024)) ;; 1mb
#+end_src

*** UI
Turning off these visual elements before UI initialization should speed up init.
#+begin_src emacs-lisp
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)
#+end_src

Implicitly resizing the Emacs frame adds to init time.
Fonts larger than the system default can cause frame resizing, which adds to startup time.
#+begin_src emacs-lisp
(setq frame-inhibit-implied-resize t)
#+end_src

Set default and backup fonts
#+begin_src emacs-lisp
(push '(font . "Source Code Pro") default-frame-alist)
(set-face-font 'default "Source Code Pro")
(set-face-font 'variable-pitch "DejaVu Sans")
(copy-face 'default 'fixed-pitch)
#+end_src
Ignore X resources.
#+begin_src emacs-lisp
(advice-add #'x-apply-session-resources :override #'ignore)
#+end_src


Taken from:

[[https://github.com/vsemyonoff/emacsrc/blob/14649a5bafea99cc7e13e7d048e9d15aed7926ce/early-init.el]]

This helps with a bug I was hitting when using =desktop-save-mode='s =desktop-read=.
#+begin_src emacs-lisp
(setq desktop-restore-forces-onscreen nil)
#+end_src

*** provide early-init
#+begin_src emacs-lisp
(provide 'early-init)
;;; early-init.el ends here
#+end_src

** lexical binding
The following line turns on lexical binding for performance reasons.
#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
#+end_src

** Straight package manager
#+begin_quote
straight.el: next-generation, purely functional package manager for the Emacs hacker.

https://github.com/raxod502/straight.el
#+end_quote
Straight installs packages directly from there git repository.

Bootstrap straight
Caveat:

#+begin_quote
Sometimes, in a corporate environment, url-retrieve-synchronously may not work and straight.el
will be unable to download the installation script mentioned in the bootstrap snippet.
In this case, you may simply clone this repository into ~/.emacs.d/straight/repos/straight.el and
check out your desired revision/branch.
#+end_quote

#+begin_src emacs-lisp
(setq straight-repository-branch "develop")
(setq straight-check-for-modifications '(check-on-save))
(setq straight-use-package-by-default t)
(setq straight-vc-git-default-protocol 'https)
(setq straight-vc-git-force-protocol nil)
(defvar bootstrap-version)
;;(setq straight-host-usernames '((github . "progfolio")
;;                                (gitlab . "iarchivedmywholelife")))
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

[[https://www.funtoo.org/Keychain][Keychain]] is a gpg/ssh agent that allows me to cache my credentials.
This package gets the correct environment variables so straight can use the ssh protocol.

#+begin_src emacs-lisp
;;(straight-use-package 'keychain-environment)
;;(require 'keychain-environment)
;;(keychain-refresh-environment)
;;(setq straight-vc-git-default-protocol 'ssh)
#+end_src

*** Install org-contrib
Installing it this early *should* prevent mixed Org installations.
#+begin_src emacs-lisp
(straight-use-package 'org-contrib)
#+end_src

** profiling
This function displays how long Emacs took to start.
It's a rough way of knowing when/if I need to optimize my init file.
#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs loaded in %s with %d garbage collecitons."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+end_src
** packaging
*** use-package
#+begin_src emacs-lisp
(defmacro use-feature (name &rest args)
  "Like `use-package' but with `straight-use-package-by-default' disabled.
NAME and ARGS are in `use-package'."
  (declare (indent defun))
  `(use-package ,name
     :straight nil
     :ensure nil
     ,@args))
#+end_src

#+begin_src emacs-lisp
(straight-use-package 'use-package)
(eval-when-compile
  (require 'use-package))
#+end_src

#+begin_src emacs-lisp
(setq init-file-debug nil)
(if init-file-debug
    (setq use-package-verbose t
          use-package-expand-minimally nil
          use-package-compute-statistics t
          debug-on-error t)
  (setq use-package-verbose nil
        use-package-expand-minimally t))
#+end_src

* Packages
** evil
#+begin_quote
Evil is an extensible vi layer for Emacs. It emulates the main features of Vim, and provides facilities for writing custom extensions.
[...] evil-collection assumes evil-want-keybinding is set to nil and evil-want-integration is set to t before loading evil and evil-collection.
https://github.com/emacs-evil/evil
#+end_quote
#+begin_src emacs-lisp
  (use-package evil
    :demand t
    :preface (setq evil-want-keybinding nil)
    :custom
    (evil-want-integration t)
    (evil-undo-system 'undo-redo)
    :hook (after-init . evil-mode))
#+end_src

*** evil-collection
#+begin_quote
This is a collection of Evil bindings for the parts of Emacs that Evil does not cover properly by default.

https://github.com/emacs-evil/evil-collection
#+end_quote
#+begin_src emacs-lisp
  (use-package evil-collection
    :after (evil)
    :config (evil-collection-init)
    :custom
    (evil-collection-setup-minibuffer t "Add evil bindings to minibuffer")
  )
#+end_src

** general (key-bindings)
#+begin_quote
general.el provides a more convenient method for binding keys in emacs (for both evil and non-evil users).

https://github.com/noctuid/general.el#about
#+end_quote

Load general before the remaining packages so they can make use of the ~:general~ keyword in their declarations.

#+begin_src emacs-lisp
(use-package general
  :demand t)
#+end_src

*** config key-bindings

#+begin_src emacs-lisp
  (general-create-definer global-definer
    :keymaps 'override
    :states  '(normal)
    :prefix  "SPC"
    )
  
  (global-definer
    "!"   'shell-command
    ":"   'eval-expression
    "TAB" '((lambda () (interactive) (switch-to-buffer nil))
        :which-key "other-buffer")
  )
#+end_src

We define a global-leader definer to access major-mode specific bindings:

#+begin_src emacs-lisp
(general-create-definer global-leader
  :keymaps 'override
  :states '(normal)
  :prefix "SPC m"
  :non-normal-prefix "C-SPC m"
  "" '( :ignore t
        :which-key
        (lambda (arg)
          (cons (cadr (split-string (car arg) " "))
                (replace-regexp-in-string "-mode$" "" (symbol-name major-mode))))))
#+end_src

And a macro to ease the creation of nested menu bindings:

#+begin_src emacs-lisp
(defmacro +general-global-menu! (name infix-key &rest body)
  "Create a definer named +general-global-NAME wrapping global-definer.
Create prefix map: +general-global-NAME. Prefix bindings in BODY with INFIX-KEY."
  (declare (indent 2))
  `(progn
     (general-create-definer ,(intern (concat "+general-global-" name))
       :wrapping global-definer
       :prefix-map (quote ,(intern (concat "+general-global-" name "-map")))
       :infix ,infix-key
       :wk-full-keys nil
       "" '(:ignore t :which-key ,name))
     (,(intern (concat "+general-global-" name))
      ,@body)))
#+end_src

**** applications
#+begin_src emacs-lisp
(+general-global-menu! "application" "a")
#+end_src

**** buffer
#+begin_src emacs-lisp
  (+general-global-menu! "buffer" "b"
    "d"  'kill-current-buffer
    "o" '((lambda () (interactive) (switch-to-buffer nil))
          :which-key "other-buffer")
    "p"  'previous-buffer
    "r"  'rename-buffer
    "R"  'revert-buffer
    "M" '((lambda () (interactive) (switch-to-buffer "*Messages*"))
          :which-key "messages-buffer")
    "n"  'next-buffer
    "s" '((lambda () (interactive) (switch-to-buffer "*scratch*"))
          :which-key "scratch-buffer")
  )
#+end_src


**** jumping/ joining / spliting
#+begin_src emacs-lisp
  (+general-global-menu! "jump" "j"
    )
#+end_src

**** files
#+begin_src emacs-lisp
  (+general-global-menu! "file" "f"
    )
#+end_src


**** git
#+begin_src emacs-lisp
(+general-global-menu! "git" "g")
#+end_src

**** windows
#+begin_src emacs-lisp
(+general-global-menu! "window" "w"
  "?" 'split-window-vertically
  "=" 'balance-windows-area
  "/" 'split-window-horizontally
  "O" 'delete-other-windows
  "X" '((lambda () (interactive) (call-interactively #'other-window) (kill-buffer-and-window))
        :which-key "kill-other-buffer-and-window")
  "H" 'evil-window-move-far-left
  "J" 'evil-window-move-very-bottom
  "K" 'evil-window-move-very-top
  "L" 'evil-window-move-far-right
  "d" 'delete-window
  "h" 'windmove-left
  "j" 'windmove-down
  "k" 'windmove-up
  "l" 'windmove-right
  "o" 'other-window
  "t" '((lambda () (interactive)
          "toggle window dedication"
          (set-window-dedicated-p (selected-window) (not (window-dedicated-p))))
        :which-key "toggle window dedication")
  "x" 'kill-buffer-and-window)
#+end_src

**** projects
#+begin_src emacs-lisp
(+general-global-menu! "project" "p"
  "b" '(:ignore t :which-key "buffer"))
#+end_src

** which-key
#+begin_quote
which-key is a minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup.

https://github.com/justbur/emacs-which-key
#+end_quote
#+begin_src emacs-lisp
(use-package which-key
  :demand t
  :init
  (setq which-key-enable-extended-define-key t)
  :config
  (which-key-mode)
  :custom
  (which-key-side-window-location 'bottom)
  (which-key-sort-order 'which-key-key-order-alpha)
  (which-key-side-window-max-width 0.33)
  (which-key-idle-delay 0.05)
  :diminish which-key-mode)
#+end_src

** magit
#+begin_quote
Magit is an interface to the version control system Git, implemented as an Emacs package.

https://magit.vc/
#+end_quote
#+begin_src emacs-lisp
  (use-package magit
    :defer t
    :after (general)
    :general
    (+general-global-git
        "b"  'magit-blame
        "i"  'magit-init
        "s"  'magit-status)
    :init
    :config
    (transient-bind-q-to-quit))
#+end_src

** company
#+begin_quote
Company is a text completion framework for Emacs.
The name stands for "complete anything".
It uses pluggable back-ends and front-ends to retrieve and display completion candidates.

http://company-mode.github.io/
#+end_quote
#+begin_src emacs-lisp :lexical t
        (use-package company
          :defer 5
        :custom
    (company-idle-delay 0.01)
      (company-minimum-prefix-length 0)
      (company-tooltip-limit 14)
      (company-tooltip-align-annotations t)
      (company-tooltip-maximum-width 50)
      (company-tooltip-minimum-width 50)
      (company-selection-wrap-around t)
      (company-require-match 'never)
    :general
    (:keymaps
  'company-active-map' "<tab>" #'company-complete-selection
     )
  )
#+end_src

** helm
#+begin_quote
Helm is an Emacs framework for incremental completions and narrowing selections.

https://github.com/emacs-helm/helm
#+end_quote
#+begin_src emacs-lisp
    (use-package helm
    :init (require 'helm-config)
    :defer 1
    :config
    (add-hook 'helm-after-initialize-hook (lambda () (with-helm-buffer (visual-line-mode))))
    (helm-mode)
    :general
    (:keymaps 'helm-map
              "TAB"   #'helm-execute-persistent-action
              "<tab>" #'helm-execute-persistent-action
              "C-a"   #'helm-select-action
              "C-h"   #'helm-find-files-up-one-level
              "C-j"   #'helm-next-line
              "C-k"   #'helm-previous-line)
    (global-definer
      "SPC" '(helm-M-x :which-key "M-x")
      "/"   'helm-occur)
    (+general-global-file
    "f" 'helm-find-files
    "F" 'helm-find
    "r" 'helm-recentf)
    (+general-global-buffer
      "b" 'helm-mini)
    (+general-global-jump
        "i" 'helm-imenu))
#+end_src

#+end_src
*** helm-projectile
#+begin_src emacs-lisp
(use-package helm-projectile
  :after (helm)
  :general
  (+general-global-project
    "d" 'helm-projectile-find-dir
    "f" 'helm-projectile-find-file
    "p" 'helm-projectile-switch-project
    "r" 'helm-projectile-recentf))
#+end_src

** projectile
#+begin_quote
Projectile is a project interaction library for Emacs.
Its goal is to provide a nice set of features operating on a project level without introducing external dependencies (when feasible).

https://github.com/bbatsov/projectile
#+end_quote
#+begin_src emacs-lisp
(use-package projectile
  :after (general)
  :general
  (+general-global-project
    "!" 'projectile-run-shell-command-in-root
    "%" 'projectile-replace-regexp
    "D" 'projectile-dired
    "e" 'projectile-edit-dir-locals
    "g" 'projectile-find-tag
    "G" 'projectile-regenerate-tags
    "R" 'projectile-replace
    "v" 'projectile-vc)
  :config
  (projectile-mode))
#+end_src

** vterm
#+begin_quote
Emacs-libvterm (vterm) is fully-fledged terminal emulator inside GNU Emacs based on libvterm, a C library.

https://github.com/akermu/emacs-libvterm
#+end_quote
#+begin_src emacs-lisp
(use-package vterm
  :straight (:post-build (cl-letf (((symbol-function #'pop-to-buffer)
                                    (lambda (buffer) (with-current-buffer buffer (message (buffer-string))))))
                           (setq vterm-always-compile-module t)
                          (require 'vterm)))
  :commands (vterm vterm-other-window)
  :general
  (+general-global-application
    "t" '(:ignore t :which-key "terminal")
    "tt" 'vterm-other-window
    "t." 'vterm)
  :config
  (evil-set-initial-state 'vterm-mode 'emacs))
#+end_src

** Development
Fowlling packages are used majorly for programming

*** lsp-mode
#+begin_quote
Client for Language Server Protocol.
lsp-mode aims to provide IDE-like experience by providing optional integration with the most popular Emacs packages like company, flycheck and projectile.
#+end_quote

#+begin_src emacs-lisp
  (use-package lsp-mode
  :hook (;; replace XXX-mode with concrete major-mode(e. g. python-mode)
         (lsp-mode . lsp-enable-which-key-integration))
  :commands lsp-deferred)
  
  (use-package lsp-ui
    :commands lsp-ui-mode)
  (use-package helm-lsp
    :commands helm-lsp-workspace-symbol)
#+end_src

*** flycheck
#+begin_quote
Flycheck is a modern on-the-fly syntax checking extension for GNU Emacs, intended as replacement for the older Flymake extension which is part of GNU Emacs.

https://www.flycheck.org/en/latest/
#+end_quote
#+begin_src emacs-lisp
  (use-package flycheck
  :init (global-flycheck-mode)
  :custom (flycheck-emacs-lisp-load-path 'inherit "necessary with straight.el"))
#+end_src

*** Python

**** lsp-pyright
#+begin_src emacs-lisp
  (use-package lsp-pyright
  :defer t
  :hook (python-mode . (lambda ()
                          (require 'lsp-pyright)
                          (lsp-deferred))))
#+end_src

**** pyvenv
#+begin_src emacs-lisp
  (use-package pyvenv
  :defer t
  :diminish
  ;;:config
  ;;(setenv "WORKON_HOME" <your-pyworkon-venvs-folder>)
  ; Show python venv name in modeline
  ;;(setq pyvenv-mode-line-indicator '(pyvenv-virtual-env-name ("[venv:" pyvenv-virtual-env-name "] ")))
  ;;(pyvenv-mode t)
  )
#+end_src




 
